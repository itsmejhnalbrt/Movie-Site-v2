ğŸ§  Why not just rely on catch?
Because fetch does NOT throw an error for HTTP failures like:
- 401 Unauthorized
- 404 Not Found
- 500 Server error

This will NOT go to catch automatically:

Even if the server returns 404, fetch resolves successfully.
So you must manually detect failure:

if (!response.ok) {
  throw new Error(errorData);
}

That line is what forces the code into catch.
Without it, this would still run:

ğŸ” Why re-throw inside catch?
catch (error) {
  console.log(error);
  throw error;
}

This means:
âœ” log the error here
âœ” BUT let whoever called this function handle it too

Example:
try {
  await api.get('discover/movie');
} catch (err) {
  setErrorMessage(err.message);
}

If you didnâ€™t re-throw:
âŒ the calling code would never know it failed
âŒ your UI wouldnâ€™t show an error
âŒ bugs get swallowed silently

EXTRA:
ğŸš« What would be wrong?
catch (error) {
  console.log(error);
}

This is dangerous because:
âŒ error disappears
âŒ app thinks request succeeded
âŒ debugging becomes painful
âŒ UI wonâ€™t react properly

âœ… Final mental model
Think of it like this:

throw = pull the fire alarm
catch = fire department arrives
rethrow = call the chief
ğŸ˜„