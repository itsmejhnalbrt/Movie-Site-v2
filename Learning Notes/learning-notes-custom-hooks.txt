CUSTOM HOOKS
You should create a custom hook when:
ğŸ‘‰ you notice the same stateful logic being repeated in multiple components
ğŸ‘‰ or when a component is getting bloated with logic
ğŸ‘‰ or when you want to separate behavior from UI

Custom hooks are for reusing logic, not JSX.

âœ… Good reasons to create a custom hook

1ï¸âƒ£ You copy-pasted logic between components
Example:
useEffect(() => {
  fetch('/api/data').then(r => r.json()).then(setData)
}, [])

If that appears in 2+ components â†’ hook it.

function useFetch(url) {
  const [data, setData] = useState(null)
  useEffect(() => {
    fetch(url).then(r => r.json()).then(setData)
  }, [url])

  return data
}

2ï¸âƒ£ Your component is hard to read
Bad:
function Dashboard() {
  const [a, setA] = useState(0)
  const [b, setB] = useState(0)
  const [c, setC] = useState(0)
  const [isOnline, setIsOnline] = useState(true)
  const [isDirty, setIsDirty] = useState(false)
  const [hasError, setHasError] = useState(false)
  // ğŸ’€ logic soup
}

Good:
const { isOnline, isDirty, hasError } = useFormStatus()

Cleaner UI, same behavior.

3ï¸âƒ£ You want logic without UI
Hooks return:
- values (state)
- functions (actions)

They should NOT return JSX.

âŒ bad hook:
function useButton() {
  return <button>Click</button>
}

âœ… good hook:
function useCounter() {
  return { count, increment }
}

4ï¸âƒ£ You need lifecycle behavior reused
Things like:
- event listeners
- timers
- subscriptions
- localStorage sync
- window size
- auth state

Perfect hook candidates.

function useWindowSize() {
  const [size, setSize] = useState(window.innerWidth)

  useEffect(() => {
    const handler = () => setSize(window.innerWidth)
    window.addEventListener('resize', handler)
    return () => window.removeEventListener('resize', handler)
  }, [])

  return size
}

ğŸš« When NOT to make a custom hook
âŒ Just to avoid typing
Bad reason:
function useMath() {
  return { sum: (a,b) => a+b }
}

Thatâ€™s just a helper function.

âŒ When logic is only used once
Donâ€™t abstract too early:
const [count, setCount] = useState(0)

This is already clean â€” no hook needed.
 
âŒ For UI reuse
Thatâ€™s a component, not a hook.

ğŸ§  Rule of thumb
Ask yourself:
â€œWould I want this exact logic in another component?â€

If yes â†’ hook
If no â†’ keep it local

ğŸ”¥ Mental model
Components = what it looks like
Hooks = what it does

----
USING A HOOK
1ï¸âƒ£ Create a hook
// useCounter.js (React)
import { useState } from 'react'

export function useCounter() {
  const [count, setCount] = useState(0)
  const increment = () => setCount(c => c + 1)

  return { count, increment }
}

2ï¸âƒ£ Use it in a component
import { useCounter } from './useCounter'

function App() {
  const { count, increment } = useCounter()

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
    </div>
  )
}
export default App

ğŸ§  Rules (important)
Custom hooks MUST:
âœ… start with use
âœ… only call hooks inside them (useState, useEffect, etc.)
âœ… be used inside React components or other hooks

âŒ not in regular functions
âŒ not conditionally

ğŸ§¨ Key difference vs Vue composables
| Vue          | React         |
| ------------ | ------------- |
| `ref()`      | `useState()`  |
| `computed()` | `useMemo()`   |
| `watch()`    | `useEffect()` |
| composable   | custom hook   |
Same pattern: logic reuse outside components.
